/**
 * @file loader.c
 */

#include "proc_parser.h"
#include "proc_structs.h"
#include "proc_gen.h"
#include "proc_syntax.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

void dealloc_process_in_mem(process_in_mem_t *p);
void dealloc_resource_list(resource_t *r);
void dealloc_mailboxes();
void dealloc_data_structures();

void print_pcb_list(char *msg);
void print_resource_list();
void print_mailbox_list();
void print_instr_list(char *msg, instr_t *nxt_instr);

void add_to_pcb_list(pcb_t *pcb); 
char *last_proc_name = "";
int last_proc_num = 0;

pcb_t *first_pcb = NULL;
pcb_t *last_pcb = NULL;

resource_t *first_resource = NULL;
resource_t *last_resource = NULL;

instr_t *first_instruction = NULL;
instr_t *last_instruction = NULL;

mailbox_t *first_mailbox = NULL;
mailbox_t *last_mailbox = NULL;

void init_loader()
{
    last_proc_name = malloc(sizeof(char));
    last_proc_name[0] = '\0';
}

/**
 * @brief Returns a pointer to the linked list of loaded PCBs 
 *
 * Returns a pointer to the first process in the linked list
 * of loaded processes parsed by proc_parser.c.
 *
 * @return A pointer to the first process control block in the linked list.
 */
struct pcb_t *init_loader_from_files(char *filename1, char *filename2) {
    pcb_t *init_procs;
    bool_t success = parse_process_file(filename1);
    if (!success) printf("Error parsing %s\n", filename1);
    print_pcb_list("Init processes");
    print_resource_list();
    init_procs = get_init_pcbs();

    success = parse_process_file(filename2);
    if (!success) printf("Error parsing %s\n", filename2);
    print_pcb_list("Arrival processes");
    print_resource_list();

    return init_procs;
}

/**
 * @brief Returns a pointer to the first process in the pcb list 
 *
 * Returns a pointer to the first process in the list
 * of loaded processes generated by proc_gen.c.
 *
 * @return firstPCB Pointer to the first process control block.
 */
struct pcb_t *init_loader_from_generator() {
    pcb_t *init_pcbs;
    /* generate processes to initialise ready queue */ 
    int success = generate_init_procs();
    if (!success) printf("Error generating procs\n");
    print_pcb_list("Init processes");
    print_resource_list();
    init_pcbs = get_init_pcbs();
 
    /* generate processes to arrive in ready queue during scheduling */ 
    success = generate_new_procs();
    if (!success) printf("Error generating procs\n");
    print_pcb_list("Arrival processes");
    print_resource_list();

    return init_pcbs; 
}

/**
 * @brief Adds the new pcb to the list of pcbs 
 *
 * Adds a newly created pcb to the list of pcbs 
 *
 * @param the pcb to add
 */
void add_to_pcb_list(pcb_t *new_pcb) {
    pcb_t *current_pcb;

    if (first_pcb == NULL) {
        first_pcb = new_pcb;
    } else {
        current_pcb = first_pcb;
        while (current_pcb->next != NULL) {
            current_pcb = current_pcb->next; 
        }
        current_pcb->next = new_pcb;
    }

    #ifdef DEBUG_LOADER
        print_pcb_list("Loaded"); 
    #endif
}

/**
 * \brief Initialises and loads the processes specified in the process.list
 * file.
 *
 * This function initialises a new process control block for the process being
 * loaded from the process.list file. It initialises a number of pointers to
 * NULL as well as setting the processState to NEW. 
 *
 * \param process_name The name of the new process to load
 */
bool_t load_process(char* process_name, int priority) {
    process_in_mem_t *new_process_in_mem = malloc(sizeof(process_in_mem_t));

    pcb_t *pcb = NULL;
    if (new_process_in_mem) {
        pcb = malloc(sizeof(pcb_t));
        pcb->process_in_mem = new_process_in_mem;
        pcb->state = NEW;
        pcb->next_instruction = NULL;
        pcb->priority = priority;
        pcb->resources = NULL;
        pcb->next = NULL;

        pcb->process_in_mem->name = process_name;
        pcb->process_in_mem->number = ++last_proc_num;

        add_to_pcb_list(pcb);
    } 
    
    if (pcb) return TRUE;
    else return FALSE;
}

/**
 * @brief Loads the mailbox from the process.list file.
 *
 * Loads a mailbox resource and adds it to the list of mailboxes. 
 *
 * @param mailbox_name The name of the mailbox to load.
 */
bool_t load_mailbox(char* mailbox_name) {
    mailbox_t *tmp_mailbox = malloc(sizeof(mailbox_t));
    int success = TRUE;  
 
    if (tmp_mailbox) {
        if (first_mailbox == NULL) {
            first_mailbox = tmp_mailbox; 
            first_mailbox->next = NULL;
            last_mailbox = first_mailbox;
        } else {
            last_mailbox->next = tmp_mailbox;
            last_mailbox = tmp_mailbox;
        }
        last_mailbox->name = mailbox_name;
        last_mailbox->next = NULL;
    } else {
        success = FALSE;
    } 
   
 #ifdef DEBUG_LOADER
     printf("Added %s; ", mailbox_name);
     print_mailbox_list();
 #endif
 
 return success;
}

/**
 * @brief Loads a resource from the process.list file.
 *
 * Loads a resource and adds it to the list of resources. The resource
 * is indicated as available and the resource name is stored.
 *
 * @param resource_name The name of the resource to load.
 */
bool_t load_resource(char *resource_name) {
    resource_t *tmp_resource = malloc(sizeof(resource_t));
    bool_t success = TRUE;  
 
    if (tmp_resource) {
        if (first_resource == NULL) {
            first_resource = tmp_resource; 
            last_resource = first_resource;
        } else {
            last_resource->next = tmp_resource;
            last_resource = tmp_resource;
        }
        last_resource->name = resource_name;
        last_resource->available = YES;
        last_resource->next = NULL;
    } else {
        success = FALSE;
    }
#ifdef DEBUG_LOADER
    printf("Added %s; ", resource_name);
    print_resource_list();
#endif

    return success;

}

/**
 * @brief Loads an instruction for a process.
 *
 * The function uses the process_name to locate the process for 
 * which the instruction should be loaded as well as the resource
 * on which the action is performed.
 *
 * @param process_name The name of the process for which to load the
 * instruction.
 * @param resource_name The name of the resource used in the instruction.
 * @param instruction Indicates the next request, release or message to send.
 */
bool_t load_instruction(char *process_name, instr_types_t instruction, 
    char *resource_name, char *msg) {
    bool_t success = TRUE;

    instr_t *tmp_instr = malloc(sizeof(struct instr_t));
    pcb_t *pcb = NULL;

    if (tmp_instr) { 
        if (strcmp(last_proc_name, process_name) != 0) {
            first_instruction = tmp_instr; 
            first_instruction->next = NULL;
            last_instruction = first_instruction;
        } else {
            tmp_instr->next = NULL;
            last_instruction->next = tmp_instr;
            last_instruction = tmp_instr;
        }
    
        last_instruction->resource_name = resource_name;
        switch (instruction) {
        case SEND_OP: 
        case RECV_OP: 
            last_instruction->type = instruction; 
            last_instruction->msg = msg;
            break;
        default: 
            last_instruction->type = instruction;
            last_instruction->msg = NULL;
            break;
        }

        pcb = first_pcb;
        if (pcb != NULL) {
            do { 
                if(strcmp(pcb->process_in_mem->name, process_name) == 0) break;
                pcb = pcb->next;
            } while (pcb != NULL); 
            pcb->next_instruction = first_instruction;
            pcb->process_in_mem->first_instr = first_instruction;
        }
        last_proc_name = process_name; 
    } else {
        success = FALSE;
    }

    return success;
}

/**
 * @brief Returns a pointer to the linked list of all loaded processes.
 * 
 * @return first_pcb Pointer to the linked list of pcbs 
 */
pcb_t *get_init_pcbs() {
    pcb_t *loaded_pcbs = first_pcb;
    first_pcb = NULL;
    last_pcb = NULL;
    return loaded_pcbs;
}

/**
 * @brief Remove the first pcb from the linked list of loaded processes and return it 
 * 
 * @return first_pcb Pointer to the first_pcb 
 */
pcb_t *get_new_pcb() {

    pcb_t *new_pcb = first_pcb;
    if (new_pcb) { /* at least one pcb left */
        first_pcb = first_pcb->next;
        new_pcb->next = NULL;
    } else { /* pcb list empty */ 
        last_pcb = NULL;
    }
    return new_pcb;
}

/**
 * @brief Returns the first pointer to the available resources.
 * 
 * Returns the first pointer to the available resources.
 *
 * @return first_resource Pointer to the resource list.
 */
struct resource_t *get_available_resources() {
    return first_resource;
}

/**
 * @brief Returns the first pointer to the available mailboxes.
 *
 * Returns the first pointer to the available mailboxes.
 *
 * @return first_mailbox Pointer to the mailbox list.
 */
struct mailbox_t* get_mailboxes() {
    return first_mailbox;
}

/**
 * @brief Returns the number of processes created 
 *
 * @return last_proc_num: id assigned to the last process  
 */
int get_num_procs() {
    return last_proc_num;
}
/**
 * @brief Frees the allocated memory for the process_in_mem struct.
 *
 * Frees the name stored in the structed followed by the struct.
 */
void dealloc_process_in_mem(struct process_in_mem_t *p) {
    if (p != NULL) {
        free(p->name);
        free(p);
    }
}

/**
 * @brief Frees the allocated memory for the instruction struct.
 *
 * Frees the instruction struct.
 */
void dealloc_instruction(struct instr_t *i) {
    if(i != NULL) {
        free(i);
    }
}

/**
 * @brief Frees the resources used in the system.
 *
 * Frees a linked list of resources 
 */
void dealloc_resource_list(resource_t *r) {
    resource_t *current_resource;
    resource_t *next_resource;

    if (r != NULL) {
        current_resource = r;
        do {
            next_resource = current_resource->next;
            free(current_resource);
            current_resource = next_resource;
        } while (current_resource != NULL);
    }
}

/**
 * @brief Frees all the memory allocated for a linked list of PCBs.
 *
 * Iterates over the loaded process PCBs, starting from current_pcb, freeing all the
 * allocated memory assigned to each process.
 */
void dealloc_pcb_list(pcb_t *current_pcb) {    
    pcb_t *next_pcb;
    instr_t *instruction;
    instr_t *next_instruction;

    if (current_pcb != NULL) {

        do {
            instruction = current_pcb->process_in_mem->first_instr;

            while (instruction != NULL) {
                next_instruction = instruction->next;
                dealloc_instruction(instruction);
                instruction = next_instruction;
            }

            dealloc_process_in_mem(current_pcb->process_in_mem);

            next_pcb = current_pcb->next;
            free(current_pcb);
            current_pcb = next_pcb;
        } while(current_pcb != NULL);
    }
}


/**
 * @brief Frees the mailboxes used in the system.
 *
 * Free each of the mailboxes which are available and used in the system.
 */
void dealloc_mailboxes() {
    mailbox_t *current_mailbox;
    mailbox_t *next_mailbox;
    
    current_mailbox = get_mailboxes();
    if(current_mailbox != NULL) {
        do {
            free(current_mailbox->name);
            if(current_mailbox->msg != NULL) {
                free(current_mailbox->msg);
            }
            next_mailbox = current_mailbox->next;
            free(current_mailbox);
            current_mailbox = next_mailbox;
        } while (current_mailbox != NULL);
    }
}

/**
 * @brief Frees the memory for all the data structures 
 *
 */
void dealloc_data_structures() {
    resource_t *availableResources;
    pcb_t *pcbs;

    /* Frees the memory for resources not assigned to processes */
    availableResources = get_available_resources();
    dealloc_resource_list(availableResources);
    pcbs = first_pcb;
    dealloc_pcb_list(pcbs);
    dealloc_mailboxes();
}

/**
 * @brief Frees the allocated memory for the process_in_mem struct.
 */
void dealloc_last_proc_name() {
    free(last_proc_name);
}

void print_pcb_list(char *msg) {
    pcb_t *current_pcb = first_pcb;
    printf("%s: ", msg);
    do {
        printf("%s (%d) ", current_pcb->process_in_mem->name, current_pcb->priority);
        current_pcb = current_pcb->next;
    } while(current_pcb != NULL);
    printf("\n");
}

void print_resource_list() {
    resource_t *current_resource = first_resource;
    printf("Resources: ");
    do {
        printf("%s ", current_resource->name);
        current_resource = current_resource->next;
    } while(current_resource != NULL);
    printf("\n");
}

void print_mailbox_list() {
    mailbox_t *current_mailbox;
    current_mailbox = first_mailbox;
    printf("mailboxes : ");
    do {
        printf("%s ", current_mailbox->name);
        current_mailbox = current_mailbox->next;
    } while(current_mailbox != NULL);
    printf("\n");
}

void print_instr_list(char *msg, instr_t *nxt_instr) {
    instr_t *cur_instr = nxt_instr;
    if (nxt_instr == NULL) cur_instr = first_instruction;
    printf("%s: ", msg);
    while (cur_instr != NULL) {
        printf("%s %s\n    ", (cur_instr->type == REQ_OP)?"req":"rel", cur_instr->resource_name);
        cur_instr = cur_instr->next;
    } 
    printf("\n");
} 
